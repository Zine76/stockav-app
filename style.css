// ----- DÉBUT DU FICHIER script.js -----
// Assure que le code s'exécute après le chargement du DOM
document.addEventListener('DOMContentLoaded', () => {
    "use strict"; // Active le mode strict pour détecter plus d'erreurs

    // --- Configuration et Variables Globales ---
    let currentUser = null;
    let currentUserCode = null;
    const ITEMS_PER_PAGE = 15;
    let isInitialAuthCheckComplete = false;
    let activeSession = null;
    let lastDisplayedDrawer = null;
    let categoriesCache = [];

    // --- Configuration Supabase ---
    const SUPABASE_URL = 'https://tjdergojgghzmopuuley.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRqZGVyZ29qZ2doem1vcHV1bGV5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM4MTU0OTUsImV4cCI6MjA1OTM5MTQ5NX0.XejQYEPYoCrgYOwW4T9g2VcmohCdLLndDdwpSYXAwPA';
    const FAKE_EMAIL_DOMAIN = '@stockav.local';
    // Nom de la fonction Edge (MODIFIÉ ÉTAPE 4)
    const AI_FUNCTION_NAME = 'ai-component-info';

    let supabase = null;

    // --- Initialisation des Clients et Vérifications ---
    try {
        if (!SUPABASE_URL || !SUPABASE_ANON_KEY || !FAKE_EMAIL_DOMAIN) {
            throw new Error("Configuration Supabase (URL, Clé Anon, Domaine Factice) manquante ou incomplète dans script.js !");
        }
        if (window.supabase && typeof window.supabase.createClient === 'function') {
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            console.log("Client Supabase initialisé.");
        } else {
            throw new Error("La librairie Supabase (supabase-js@2) n'est pas chargée correctement avant ce script.");
        }
        if (typeof Papa === 'undefined') {
            console.warn("Librairie PapaParse non chargée. L'import CSV ne fonctionnera pas.");
        }
    } catch (error) {
        console.error("Erreur critique lors de l'initialisation:", error);
        const body = document.querySelector('body');
        if (body) {
             body.innerHTML = `<div style="padding: 20px; background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; border-radius: .25rem; font-family: sans-serif;"><h2>Erreur Critique</h2><p>L'application n'a pas pu démarrer correctement.</p><p><strong>Détails :</strong> ${error.message}</p><p>Veuillez vérifier la console du navigateur (F12) pour plus d'informations et vous assurer que les librairies externes sont correctement chargées.</p></div>`;
        }
        return;
    }

    // --- Récupération des Éléments DOM ---
    // (Identique aux étapes précédentes)...
    const loginArea = document.getElementById('login-area');
    const loginCodeInput = document.getElementById('login-code');
    const loginPasswordInput = document.getElementById('login-password');
    const loginButton = document.getElementById('login-button');
    const loginError = document.getElementById('login-error');
    const userInfoArea = document.getElementById('user-info-area');
    const userDisplay = document.getElementById('user-display');
    const logoutButton = document.getElementById('logout-button');
    const mainNavigation = document.getElementById('main-navigation');
    const searchTabButton = document.getElementById('show-search-view');
    const inventoryTabButton = document.getElementById('show-inventory-view');
    const logTabButton = document.getElementById('show-log-view');
    const adminTabButton = document.getElementById('show-admin-view');
    const settingsTabButton = document.getElementById('show-settings-view');
    const searchView = document.getElementById('search-view');
    const inventoryView = document.getElementById('inventory-view');
    const logView = document.getElementById('log-view');
    const adminView = document.getElementById('admin-view');
    const settingsView = document.getElementById('settings-view');
    const viewSections = document.querySelectorAll('.view-section');
    const protectedButtons = document.querySelectorAll('.nav-button.protected');
    const quantityChangeModal = document.getElementById('quantity-change-modal');
    const modalOverlay = document.getElementById('modal-overlay');
    const modalRefSpan = document.getElementById('modal-component-ref');
    const modalQtySpan = document.getElementById('modal-current-quantity');
    const modalDecreaseButton = document.getElementById('modal-decrease-button');
    const modalIncreaseButton = document.getElementById('modal-increase-button');
    const modalChangeAmountDisplay = document.getElementById('modal-change-amount');
    const modalConfirmButton = document.getElementById('modal-confirm-button');
    const modalCancelButton = document.getElementById('modal-cancel-button');
    const modalFeedback = document.getElementById('modal-feedback');
    const modalAttributesSection = document.querySelector('.modal-attributes-section');
    const modalAttributesList = document.getElementById('modal-component-attributes');
    const sevenSegmentDisplay = document.getElementById('seven-segment-display');
    const segmentDigits = [
        sevenSegmentDisplay?.querySelector('.digit-1'), sevenSegmentDisplay?.querySelector('.digit-2'),
        sevenSegmentDisplay?.querySelector('.digit-3'), sevenSegmentDisplay?.querySelector('.digit-4')
    ];
    let modalCurrentRef = null;
    let modalInitialQuantity = 0;
    let currentModalChange = 0;
    let currentInventoryPage = 1;
    let currentLogPage = 1;
    let currentInventoryFilters = { category: 'all', search: '' };
    const inventoryTableBody = document.getElementById('inventory-table-body');
    const inventoryCategoryFilter = document.getElementById('inventory-category-filter');
    const inventorySearchFilter = document.getElementById('inventory-search-filter');
    const applyInventoryFilterButton = document.getElementById('apply-inventory-filter-button');
    const inventoryPrevPageButton = document.getElementById('inventory-prev-page');
    const inventoryNextPageButton = document.getElementById('inventory-next-page');
    const inventoryPageInfo = document.getElementById('inventory-page-info');
    const inventoryNoResults = document.getElementById('inventory-no-results');
    const logTableBody = document.getElementById('log-table-body');
    const logPrevPageButton = document.getElementById('log-prev-page');
    const logNextPageButton = document.getElementById('log-next-page');
    const logPageInfo = document.getElementById('log-page-info');
    const logNoResults = document.getElementById('log-no-results');
    const logFeedbackDiv = document.getElementById('log-feedback');
    const categoryList = document.getElementById('category-list');
    const categoryForm = document.getElementById('category-form');
    const categoryNameInput = document.getElementById('category-name');
    const categoryAttributesInput = document.getElementById('category-attributes');
    const categoryIdEditInput = document.getElementById('category-id-edit');
    const cancelEditButton = document.getElementById('cancel-edit-button');
    const categoryFormTitle = document.getElementById('category-form-title');
    const adminFeedbackDiv = document.getElementById('admin-feedback');
    const stockForm = document.getElementById('stock-form');
    const componentRefAdminInput = document.getElementById('component-ref-admin');
    const checkStockButton = document.getElementById('check-stock-button');
    const componentInfoDiv = document.getElementById('component-info');
    const currentQuantitySpan = document.getElementById('current-quantity');
    const updateQuantityButton = document.getElementById('update-quantity-button');
    const quantityChangeInput = document.getElementById('quantity-change');
    const componentCategorySelectAdmin = document.getElementById('component-category-select');
    const specificAttributesDiv = document.getElementById('category-specific-attributes');
    const componentDescInput = document.getElementById('component-desc');
    const componentMfgInput = document.getElementById('component-mfg');
    const componentDatasheetInput = document.getElementById('component-datasheet');
    const componentInitialQuantityInput = document.getElementById('component-initial-quantity');
    const componentDrawerAdminInput = document.getElementById('component-drawer-admin');
    const componentThresholdInput = document.getElementById('component-threshold');
    const saveComponentButton = document.getElementById('save-component-button');
    const searchButtonChat = document.getElementById('search-button');
    const componentInputChat = document.getElementById('component-input');
    const responseOutputChat = document.getElementById('response-output');
    const loadingIndicatorChat = document.getElementById('loading-indicator');
    const exportInventoryCsvButton = document.getElementById('export-inventory-csv-button');
    const exportLogTxtButton = document.getElementById('export-log-txt-button');
    const exportFeedbackDiv = document.getElementById('export-feedback');
    const importCsvFileInput = document.getElementById('import-csv-file');
    const importInventoryCsvButton = document.getElementById('import-inventory-csv-button');
    const importFeedbackDiv = document.getElementById('import-feedback');
    const importModeRadios = document.querySelectorAll('input[name="import-mode"]');

    // --- État et Historique du Chat ---
    let chatHistory = [];
    let conversationState = {
        awaitingEquivalentChoice: false,
        awaitingQuantityConfirmation: false,
        originalRefChecked: null,
        potentialEquivalents: [],
        chosenRefForStockCheck: null,
        availableQuantity: 0,
        criticalThreshold: null
    };
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

    // --- Helper: Statut du Stock ---
    function getStockStatus(quantity, threshold) { /* ... Identique ... */ }
    function createStockIndicatorHTML(quantity, threshold) { /* ... Identique ... */ }
    // --- Authentification ---
    async function handleLogin() { /* ... Identique ... */ }
    async function handleLogout() { /* ... Identique ... */ }
    async function setupAuthListener() { /* ... Identique ... */ }
    function handleUserConnected(user, isInitialLoad) { /* ... Identique ... */ }
    function handleUserDisconnected(isInitialLoad) { /* ... Identique ... */ }
    function clearProtectedViewData() { /* ... Identique ... */ }
    // --- Navigation ---
    function setActiveView(viewToShow, buttonToActivate){ /* ... Identique ... */ }
    // --- LOGIQUE INVENTAIRE ---
    async function populateInventoryFilters() { /* ... Identique ... */ }
    async function displayInventory(page = currentInventoryPage) { /* ... Identique ... */ }
    // --- LOGIQUE HISTORIQUE ---
    async function displayLog(page = currentLogPage) { /* ... Identique ... */ }
    function formatLogTimestamp(date) { /* ... Identique ... */ }
    async function addLogEntry(itemRef, change, newQuantity) { /* ... Identique ... */ }
    function showLogFeedback(message, type = 'info') { /* ... Identique ... */ }
    async function handleDeleteSingleLog(event) { /* ... Identique ... */ }
    async function handleDeleteAllLogs() { /* ... Identique ... */ }
    // --- VUE ADMIN ---
    async function getCategories() { /* ... Identique ... */ }
    function invalidateCategoriesCache() { /* ... Identique ... */ }
    async function loadAdminData() { /* ... Identique ... */ }
    async function loadCategoriesAdmin() { /* ... Identique ... */ }
    function addCategoryEventListeners() { /* ... Identique ... */ }
    function resetCategoryForm(){ /* ... Identique ... */ }
    function addComponentCategorySelectListener() { /* ... Identique ... */ }
    function showAdminFeedback(message, type = 'info'){ /* ... Identique ... */ }
    function resetStockForm() { /* ... Identique ... */ }
    function addStockEventListeners() { /* ... Identique ... */ }

    // --- LOGIQUE VUE RECHERCHE (Chat - MODIFIÉE POUR ÉTAPE 4) ---

    async function addMessageToChat(sender, messageContent, isHTML = false) {
        if (!responseOutputChat) return;
        const messageElement = document.createElement('div');
        messageElement.classList.add('message', sender.toLowerCase());
        responseOutputChat.prepend(messageElement); // Ajoute en haut

        if (sender === 'AI') {
            loadingIndicatorChat.style.display = 'block';
            loadingIndicatorChat.querySelector('i').textContent = 'StockAV réfléchit...';
            messageElement.innerHTML = '...';
            await delay(150); // Court délai pour afficher '...'
            if (isHTML) {
                messageElement.innerHTML = messageContent; // Injecte directement le HTML
            } else {
                // Effet de frappe (si pas HTML)
                messageElement.textContent = '';
                for (let i = 0; i < messageContent.length; i++) {
                    messageElement.textContent += messageContent[i];
                    // Optionnel: ajuster la vitesse de l'effet de frappe
                    if (messageContent[i] !== ' ') await delay(5);
                }
            }
            loadingIndicatorChat.style.display = 'none';
        } else {
            messageElement.textContent = messageContent;
        }

        // Gérer l'historique du chat (limité)
        const role = sender === 'User' ? 'user' : 'assistant';
        chatHistory.push({ role: role, content: messageContent });
        if (chatHistory.length > 10) { // Garder les 10 derniers messages
            chatHistory.splice(0, chatHistory.length - 10);
        }

        responseOutputChat.scrollTop = 0; // Scroll en haut après ajout
    }

    function displayWelcomeMessage() {
        if (responseOutputChat) responseOutputChat.innerHTML = '';
        chatHistory = [];
        resetConversationState();
        addMessageToChat('AI', "Bonjour ! Je suis StockAV. Posez-moi une question sur un composant (dispo, équivalents, description, pinout, comparaison) ou entrez une référence.");
        if(componentInputChat) {
            componentInputChat.value = '';
            componentInputChat.focus();
        }
    }

    // Fonction principale pour gérer l'entrée utilisateur dans le chat (MODIFIÉE ÉTAPE 4)
    async function handleUserInput() {
        const userInput = componentInputChat?.value.trim();
        if (!userInput) return;

        addMessageToChat('User', userInput);
        if (componentInputChat) componentInputChat.value = '';
        resetConversationState(); // Réinitialise l'état avant chaque nouvelle requête utilisateur

        try {
            // 1. Essayer d'extraire une référence directe
            const potentialRef = extractReference(userInput);

            if (potentialRef) {
                // Si une réf est trouvée, demander les équivalents (comportement par défaut)
                console.log(`Référence détectée: ${potentialRef}. Recherche d'équivalents.`);
                await handleAIChatRequest('equivalents', potentialRef);
            } else {
                // 2. Si pas de référence, essayer de parser une intention conversationnelle
                const intentInfo = parseIntentAndRefs(userInput);
                if (intentInfo.intent !== 'unknown') {
                    console.log(`Intention détectée: ${intentInfo.intent}`, intentInfo.refs);
                    if (intentInfo.refs.length > 0) {
                        await handleAIChatRequest(intentInfo.intent, intentInfo.refs[0], intentInfo.refs[1] || null);
                    } else {
                        await addMessageToChat('AI', `Pour ${intentInfo.intent}, veuillez spécifier la (les) référence(s) du composant.`);
                    }
                } else {
                    // 3. Si ni référence ni intention claire
                    console.log("Ni référence ni intention claire détectée.");
                    await addMessageToChat('AI', "Désolé, je n'ai pas bien compris. Pouvez-vous reformuler ? Essayez d'entrer une référence (ex: 'LM358'), ou demandez 'décris LM358', 'pinout 74HC595', 'compare LM358 vs TL072'.");
                }
            }
        } catch (error) {
            console.error("Erreur majeure dans handleUserInput:", error);
            await addMessageToChat('AI', "Oups ! Une erreur interne s'est produite. Veuillez réessayer.");
            resetConversationState();
        } finally {
            if(componentInputChat) componentInputChat.focus();
        }
    }

    // Fonction pour parser l'intention et les références (NOUVEAU ÉTAPE 4)
    function parseIntentAndRefs(text) {
        const upperText = text.toUpperCase();
        let intent = 'unknown';
        let refs = [];

        // Regex pour extraire les références (similaire à extractReference mais peut capturer plusieurs)
        const refPattern = /\b(?:PIC|AT[TINYMEGAXMEGA]+|STM32[A-Z]|ESP-?|IRF|LM|NE|UA|MAX|SN74|CD4|BC|BD|TIP|MOC)[\s\-]?\d+[A-Z\d\-/]*\b|\b[1-9]N\s?\d{4}[A-Z]*\b|\b[2-9][NP]\s?\d{4}[A-Z]*\b|\b[A-Z]{2,}\d{2,}[A-Z\d\-/]*\b/g;
        let match;
        while ((match = refPattern.exec(upperText)) !== null) {
            refs.push(match[0].replace(/\s+/g, ''));
        }
        // Prioriser les refs les plus longues si plusieurs sont extraites (heuristique simple)
        refs.sort((a, b) => b.length - a.length);
        refs = [...new Set(refs)]; // Garder uniques

        // Détection d'intention (priorité à la comparaison)
        if (/\b(COMPARE|COMPARER|VS|CONTRE)\b/.test(upperText)) {
            intent = 'compare';
            if (refs.length < 2) intent = 'unknown'; // Besoin de 2 refs pour comparer
        } else if (/\b(PINOUT|BROCHAGE|PATTES|PIN-OUT)\b/.test(upperText)) {
            intent = 'pinout';
            if (refs.length === 0) intent = 'unknown';
        } else if (/\b(D[EÉ]CRIS|DESCRIPTION|INFO|CARACT[EÉ]RISTIQUES?|DETAILS?|QU'EST-CE)\b/.test(upperText)) {
            intent = 'describe';
             if (refs.length === 0) intent = 'unknown';
        } else if (/\b(EQUIVALENTS?|REMPLACANTS?|SIMILAIRES?|ALTERNATIVES?)\b/.test(upperText)) {
             intent = 'equivalents';
             if (refs.length === 0) intent = 'unknown';
        }
         // Si l'intention est trouvée mais qu'il manque les refs, on renvoie l'intention quand même
         // pour pouvoir demander les refs à l'utilisateur.

        return { intent: intent, refs: refs.slice(0, 2) }; // Prend max 2 refs
    }


    // Fonction pour appeler la fonction Edge et gérer la réponse (NOUVEAU/MODIFIÉ ÉTAPE 4)
    async function handleAIChatRequest(requestType, ref1, ref2 = null) {
        if (!ref1) {
            await addMessageToChat('AI', `Il me manque la référence du composant pour effectuer l'action "${requestType}".`);
            return;
        }
        if (requestType === 'compare' && !ref2) {
             await addMessageToChat('AI', `Pour comparer, j'ai besoin de deux références de composants.`);
             return;
        }

        loadingIndicatorChat.style.display = 'block';
        let loadingMessage = `Recherche ${requestType} pour ${ref1}...`;
        if (requestType === 'compare') loadingMessage = `Comparaison entre ${ref1} et ${ref2}...`;
        else if (requestType === 'equivalents') loadingMessage = `Recherche stock et équivalents pour ${ref1}...`;

        loadingIndicatorChat.querySelector('i').textContent = loadingMessage;
        resetConversationState(); // Assure qu'on ne reste pas en attente d'une action précédente

        const payload = {
            request_type: requestType,
            reference1: ref1.toUpperCase(),
            reference2: ref2 ? ref2.toUpperCase() : null
        };

        console.log(`Appel func Edge '${AI_FUNCTION_NAME}' avec payload:`, payload);

        try {
            const { data: result, error: invokeError } = await supabase.functions.invoke(AI_FUNCTION_NAME, {
                body: payload
            });

            loadingIndicatorChat.style.display = 'none';

            if (invokeError) {
                throw new Error(`Erreur communication service IA: ${invokeError.message}`);
            }

            if (!result || result.response_type === 'error') {
                throw new Error(result?.content || "Réponse invalide ou erreur du service IA.");
            }

            console.log("Réponse reçue de la fonction Edge:", result);

            // Traiter la réponse en fonction du type
            switch (result.response_type) {
                case 'equivalents':
                    // Réutiliser checkComponentWithAI pour l'affichage et la vérif stock local
                    // On passe les équivalents reçus et la réf originale
                    await displayEquivalentsResult(ref1, result.content);
                    break;
                case 'describe':
                case 'pinout':
                    // Afficher directement le contenu textuel
                    await addMessageToChat('AI', `Voici ${result.response_type === 'describe' ? 'la description' : 'le brochage'} pour <strong>${ref1}</strong>:\n\n${result.content}`);
                     await delay(300);
                     await addMessageToChat('AI', "Autre chose ?");
                    break;
                case 'comparison':
                    // Formater la comparaison pour l'affichage
                    let comparisonHTML = `Comparaison entre <strong>${ref1}</strong> et <strong>${ref2}</strong>:<br><br>`;
                    if (result.content && typeof result.content === 'object') {
                        if (result.content.similarities && result.content.similarities.length > 0) {
                            comparisonHTML += "<strong>Similitudes :</strong><ul>";
                            result.content.similarities.forEach(s => comparisonHTML += `<li>${s}</li>`);
                            comparisonHTML += "</ul>";
                        }
                        if (result.content.differences && result.content.differences.length > 0) {
                            comparisonHTML += "<br><strong>Différences :</strong><ul>";
                            result.content.differences.forEach(d => comparisonHTML += `<li>${d}</li>`);
                            comparisonHTML += "</ul>";
                        }
                        if (result.content.notes) { // Si l'IA ajoute des notes
                             comparisonHTML += `<br><i>Note IA: ${result.content.notes}</i>`;
                        }
                        if (!comparisonHTML.includes('<li>')) { // Si aucun point n'a été listé
                           comparisonHTML += "L'IA n'a pas fourni de points de comparaison spécifiques.";
                        }
                    } else if (typeof result.content === 'string') {
                        // Si la réponse est juste du texte
                        comparisonHTML += result.content.replace(/\n/g, '<br>'); // Simple formatage
                    } else {
                        comparisonHTML += "Impossible de formater la réponse de comparaison.";
                    }
                    await addMessageToChat('AI', comparisonHTML, true);
                    await delay(300);
                    await addMessageToChat('AI', "Puis-je aider avec autre chose ?");
                    break;
                default:
                    console.warn("Type de réponse IA non géré:", result.response_type);
                    await addMessageToChat('AI', "J'ai reçu une réponse de l'IA, mais je ne sais pas comment l'afficher.");
            }

        } catch (error) {
            console.error(`Erreur dans handleAIChatRequest pour ${requestType}:`, error);
            loadingIndicatorChat.style.display = 'none';
            await addMessageToChat('AI', `Désolé, une erreur s'est produite: ${error.message}`);
            resetConversationState();
        }
    }

    // Fonction spécifique pour traiter et afficher les résultats des équivalents (MODIFIÉE ÉTAPE 4)
    async function displayEquivalentsResult(originalRef, equivalents = []) {
        let originalStockInfo = null;
        let responseHTML = "";
        conversationState.originalRefChecked = originalRef; // Mémoriser la réf originale demandée

        try {
            // 1. Vérifier le stock de l'original
            loadingIndicatorChat.querySelector('i').textContent = `Vérification stock local ${originalRef}...`;
            originalStockInfo = await getStockInfoFromSupabase(originalRef);
            await delay(150);
            if (currentUser && originalStockInfo?.drawer) {
                updateSevenSegmentDisplay(originalStockInfo.drawer);
            }

            const showDrawer = currentUser && originalStockInfo?.drawer;
            let originalStatusHTML = "";
            if (originalStockInfo) {
                const indicatorHTML = createStockIndicatorHTML(originalStockInfo.quantity, originalStockInfo.critical_threshold);
                originalStatusHTML = (originalStockInfo.quantity > 0)
                    ? `${indicatorHTML}Original <strong>${originalRef}</strong> : Disponible (Qté: ${originalStockInfo.quantity}${showDrawer ? `, Tiroir: ${originalStockInfo.drawer}` : ''}).`
                    : `${indicatorHTML}Original <strong>${originalRef}</strong> : En rupture localement.`;
                if (originalStockInfo.quantity > 0) {
                    conversationState.criticalThreshold = originalStockInfo.critical_threshold; // Pour la demande de quantité
                }
            } else {
                originalStatusHTML = `${createStockIndicatorHTML(undefined, undefined)}Original <strong>${originalRef}</strong> : Non trouvé localement.`;
            }
            responseHTML += originalStatusHTML;

            // 2. Vérifier le stock des équivalents reçus
            let equivalentsStockInfo = {};
            if (equivalents && equivalents.length > 0) {
                loadingIndicatorChat.querySelector('i').textContent = `Vérification stock local des équivalents...`;
                const equivalentRefs = equivalents.map(eq => eq.ref);
                // Utiliser Promise.all pour paralléliser les vérifications de stock
                const stockCheckPromises = equivalentRefs.map(ref => getStockInfoFromSupabase(ref));
                const results = await Promise.all(stockCheckPromises);
                results.forEach((stockInfo, index) => {
                    if (stockInfo) {
                        equivalentsStockInfo[equivalentRefs[index]] = stockInfo;
                    }
                });
                console.log("Stock info pour équivalents:", equivalentsStockInfo);

                // 3. Construire le HTML pour les équivalents
                responseHTML += "<br><br><strong>Équivalents suggérés :</strong>";
                let foundAvailableEquivalent = false;
                equivalents.forEach(eq => {
                    const eqStock = equivalentsStockInfo[eq.ref];
                    const eqIndicatorHTML = createStockIndicatorHTML(eqStock?.quantity, eqStock?.critical_threshold);
                    const eqShowDrawer = currentUser && eqStock?.drawer;
                    responseHTML += `<div class="equivalent-item">`;
                    responseHTML += `${eqIndicatorHTML}<strong>${eq.ref}</strong> <small>(${eq.reason || 'Suggestion AI'})</small>`;
                    if (eqStock) {
                        if (eqStock.quantity > 0) {
                            foundAvailableEquivalent = true;
                            responseHTML += ` : Dispo (Qté: ${eqStock.quantity}${eqShowDrawer ? `, Tiroir: ${eqStock.drawer}` : ''})`;
                            if (currentUser) {
                                // Bouton "Prendre" pour l'équivalent
                                responseHTML += ` <button class="choice-button take-button" data-ref="${eq.ref}" data-qty="${eqStock.quantity}" data-threshold="${eqStock.critical_threshold ?? ''}">Prendre</button>`;
                            }
                        } else {
                            responseHTML += ` : Rupture local.`;
                            responseHTML += provideExternalLinksHTML(eq.ref, true); // Liens externes si en rupture
                        }
                    } else {
                        responseHTML += ` : Non trouvé local.`;
                        responseHTML += provideExternalLinksHTML(eq.ref, true); // Liens externes si non trouvé
                    }
                    responseHTML += `</div>`;
                });
                // Activer l'état d'attente si un équivalent ou l'original est dispo
                 if (foundAvailableEquivalent || (originalStockInfo && originalStockInfo.quantity > 0)) {
                    conversationState.awaitingEquivalentChoice = true;
                }
            } else {
                responseHTML += "<br><br>Aucun équivalent suggéré.";
            }

            // 4. Ajouter bouton "Prendre original" si dispo et connecté
            if (originalStockInfo && originalStockInfo.quantity > 0 && currentUser) {
                responseHTML += `<br><button class="choice-button take-button" data-ref="${originalRef}" data-qty="${originalStockInfo.quantity}" data-threshold="${originalStockInfo.critical_threshold ?? ''}">Prendre l'original (${originalRef})</button>`;
                conversationState.awaitingEquivalentChoice = true;
            } else if (originalStockInfo && originalStockInfo.quantity > 0 && !currentUser) {
                responseHTML += `<br><br><i>L'original est disponible. Connectez-vous pour pouvoir le prendre.</i>`;
            }

            // 5. Ajouter liens externes pour l'original si non dispo ou non trouvé
            if (!originalStockInfo || originalStockInfo.quantity <= 0) {
                responseHTML += provideExternalLinksHTML(originalRef, false);
            }

             // 6. Gérer la suite de la conversation
             if (!conversationState.awaitingEquivalentChoice && !conversationState.awaitingQuantityConfirmation) {
                 responseHTML += "<br><br>Puis-je vous aider avec autre chose ?";
                 resetConversationState(); // Pas d'action possible, on reset
             } else if (!currentUser && conversationState.awaitingEquivalentChoice) {
                 // Si des actions sont possibles mais user non connecté
                 responseHTML += `<br><br><i>Connectez-vous pour choisir ou prendre un composant.</i>`;
             }

            await addMessageToChat('AI', responseHTML, true);

        } catch (error) {
            console.error("Erreur lors de l'affichage des résultats d'équivalents:", error);
            await addMessageToChat('AI', `Une erreur s'est produite lors de la vérification du stock pour ${originalRef} et ses équivalents: ${error.message}`);
            resetConversationState();
        } finally {
             loadingIndicatorChat.style.display = 'none';
        }
    }


    // --- Ancienne fonction getAIEquivalents (supprimée ou commentée car remplacée par handleAIChatRequest) ---
    /* async function getAIEquivalents(reference) { ... } */

    // Gestionnaire de clic dans la zone de chat (MODIFIÉ ÉTAPE 4)
    responseOutputChat?.addEventListener('click', async (event) => {
        const targetButton = event.target.closest('button.choice-button.take-button');

        // Gérer clic sur bouton "Prendre"
        if (targetButton && conversationState.awaitingEquivalentChoice) {
            const chosenRef = targetButton.dataset.ref;
            const availableQtyStr = targetButton.dataset.qty;
            const criticalThresholdStr = targetButton.dataset.threshold;

            if (!chosenRef || availableQtyStr === undefined) {
                console.warn("Bouton 'Prendre' cliqué sans data-ref ou data-qty."); return;
            }
            const availableQty = parseInt(availableQtyStr, 10);
            if (isNaN(availableQty) || availableQty <= 0) {
                console.warn(`Quantité invalide (${availableQtyStr}) sur bouton 'Prendre' pour ${chosenRef}.`); return;
            }

            if (!currentUser) {
                await promptLoginBeforeAction(`prendre ${chosenRef}`);
                return;
            }

            console.log(`Action 'Prendre' choisie pour: ${chosenRef}, Qté dispo: ${availableQty}`);
            conversationState.awaitingEquivalentChoice = false; // On a fait un choix
            addMessageToChat('User', `Je choisis de prendre ${chosenRef}`); // Message utilisateur implicite
            await delay(50);

            // Mémoriser les infos pour la demande de quantité
            conversationState.chosenRefForStockCheck = chosenRef;
            conversationState.availableQuantity = availableQty;
            conversationState.criticalThreshold = (criticalThresholdStr && !isNaN(parseInt(criticalThresholdStr, 10))) ? parseInt(criticalThresholdStr, 10) : null;
            conversationState.awaitingQuantityConfirmation = true; // On attend la quantité

            // Mettre à jour 7-seg si tiroir connu
            const stockInfo = await getStockInfoFromSupabase(chosenRef);
            if (currentUser && stockInfo?.drawer) {
                updateSevenSegmentDisplay(stockInfo.drawer);
            }

            // Demander la quantité
            await addMessageToChat('AI', `Combien de <strong>${chosenRef}</strong> souhaitez-vous prendre ? (Stock actuel: ${availableQty}) Entrez un nombre ou '0' pour annuler.`);

        } else if (event.target.tagName === 'A' && (event.target.classList.contains('external-link') || event.target.classList.contains('external-link-inline'))) {
            // Simple log si clic sur lien externe
            console.log(`Lien externe cliqué: ${event.target.href}`);
            // Le comportement par défaut (ouvrir lien) se produira
        }
    });

    async function promptLoginBeforeAction(actionDescription) { await addMessageToChat('AI', `Pour ${actionDescription}, veuillez d'abord vous connecter en utilisant la zone en haut de la page.`); loginCodeInput?.focus(); }
    function provideExternalLinksHTML(ref, inline = false) { /* ... Identique ... */ }

    // Gérer la réponse de quantité (MODIFIÉ ÉTAPE 4 - principalement les messages)
    async function handleQuantityResponse(userInput) {
        const ref = conversationState.chosenRefForStockCheck;
        // Sécurité: vérifier si on est bien en attente d'une quantité
        if (!ref || !conversationState.awaitingQuantityConfirmation) {
             console.warn("handleQuantityResponse appelé alors qu'on n'attendait pas de quantité.");
             // Tenter de relancer une recherche si l'utilisateur a entré autre chose
             resetConversationState();
             await handleUserInput(); // Ré-évaluer l'entrée comme une nouvelle requête
             return;
        }

        const requestedQty = parseInt(userInput, 10);

        if (isNaN(requestedQty) || requestedQty < 0) {
            await addMessageToChat('AI', `Quantité invalide. Veuillez entrer un nombre positif (ex: 5) ou '0' pour annuler.`);
            // On reste en attente de la quantité
            return;
        }

        if (requestedQty === 0) {
            await addMessageToChat('AI', "Opération annulée.");
            resetConversationState();
            await delay(300);
            await addMessageToChat('AI', "Comment puis-je vous aider maintenant ?");
            return;
        }

        if (requestedQty > conversationState.availableQuantity) {
            await addMessageToChat('AI', `Quantité demandée (${requestedQty}) supérieure au stock disponible (${conversationState.availableQuantity}). Veuillez entrer une quantité valide ou '0' pour annuler.`);
            // On reste en attente de la quantité
            return;
        }

        loadingIndicatorChat.style.display = 'block';
        loadingIndicatorChat.querySelector('i').textContent = `Mise à jour du stock pour ${ref}...`;
        const change = -requestedQty;

        try {
            const newQty = await updateStockInSupabase(ref, change); // Met à jour DB et log l'entrée
            loadingIndicatorChat.style.display = 'none';

            if (newQty !== null) {
                const statusIndicatorHTML = createStockIndicatorHTML(newQty, conversationState.criticalThreshold);
                await addMessageToChat('AI', `${statusIndicatorHTML}Ok ! ${requestedQty} unité(s) de <strong>${ref}</strong> retirée(s) du stock. Nouveau stock : ${newQty}.`);
                // Rafraîchir la vue inventaire si elle est active
                if (inventoryView.classList.contains('active-view')) {
                    displayInventory(currentInventoryPage);
                }
                resetConversationState(); // Opération réussie, on reset l'état
                await delay(300);
                await addMessageToChat('AI', "Puis-je faire autre chose pour vous ?");
            }
             // Si newQty est null, updateStockInSupabase a déjà levé une erreur gérée dans le catch
        } catch (error) {
            console.error("Erreur màj stock via chat:", error);
            loadingIndicatorChat.style.display = 'none';
            let errorMessage = `Erreur lors de la mise à jour du stock pour <strong>${ref}</strong>.`;

            if (error.message.includes("Stock insuffisant")) {
                 errorMessage = `Erreur : Le stock de <strong>${ref}</strong> est insuffisant (${error.message}).`;
                 // Essayer de récupérer le stock actuel réel pour informer l'utilisateur
                 const currentStock = await getStockInfoFromSupabase(ref);
                 if(currentStock) {
                     errorMessage += ` Le stock actuel réel est: ${currentStock.quantity}. Veuillez réessayer avec une quantité valide ou '0'.`;
                     conversationState.availableQuantity = currentStock.quantity; // Mettre à jour la quantité connue
                     conversationState.awaitingQuantityConfirmation = true; // Rester en attente
                     await addMessageToChat('AI', errorMessage);
                     return; // Ne pas réinitialiser l'état, attendre nouvelle quantité
                 }
            } else if (error.message) {
                 errorMessage += ` Détails: ${error.message}`;
            }

            // Si erreur non gérée spécifiquement (ou si getStockInfo échoue), on abandonne et reset
            resetConversationState();
            await addMessageToChat('AI', errorMessage);
            await delay(300);
            await addMessageToChat('AI', "Que souhaitez-vous faire maintenant ?");
        }
    }

    function resetConversationState() { conversationState = { awaitingEquivalentChoice: false, awaitingQuantityConfirmation: false, originalRefChecked: null, potentialEquivalents: [], chosenRefForStockCheck: null, availableQuantity: 0, criticalThreshold: null }; console.log("État conversationnel du chat réinitialisé."); }
    function extractReference(text) { /* ... Identique ... */ }

    // --- Fonctions d'interaction Supabase ---
    async function getStockInfoFromSupabase(ref) { /* ... Identique (assure que 'attributes' est sélectionné) ... */ }
    async function updateStockInSupabase(ref, change) { /* ... Identique ... */ }
    // --- Gestion Modale Quantité (+/-) ---
    async function handleInventoryRowClick(event) { /* ... Identique (passe item à showQuantityModal) ... */ }
    function showQuantityModal(item) { /* ... Identique (gère l'affichage des attributs) ... */ }
    function hideQuantityModal() { /* ... Identique ... */ }
    function updateModalButtonStates() { /* ... Identique ... */ }
    // (Listeners de la modale identiques)
    modalDecreaseButton?.addEventListener('click', () => { /* ... */ });
    modalIncreaseButton?.addEventListener('click', () => { /* ... */ });
    modalCancelButton?.addEventListener('click', hideQuantityModal);
    modalOverlay?.addEventListener('click', (event) => { /* ... */ });
    modalConfirmButton?.addEventListener('click', async () => { /* ... Identique ... */ });

    // --- Gestion Afficheur 7 Segments ---
    const segmentMap = { /* ... Identique ... */ };
    function updateSevenSegmentDisplay(newDrawerValue = undefined) { /* ... Identique ... */ }
    // --- Logique pour la vue Paramètres ---
    function loadSettingsData() { /* ... Identique ... */ }
    function showSettingsFeedback(type, message, level = 'info') { /* ... Identique ... */ }
    function downloadFile(filename, content, mimeType) { /* ... Identique ... */ }
    async function handleExportInventoryCSV() { /* ... Identique ... */ }
    async function handleExportLogTXT() { /* ... Identique ... */ }
    async function handleImportInventoryCSV() { /* ... Identique (gère mode overwrite/upsert) ... */ }
    function resetImportState() { /* ... Identique ... */ }
    function addSettingsEventListeners() { /* ... Identique ... */ }

    // --- Initialisation Générale de l'Application ---
    function initializeApp() {
        console.log("Initialisation de StockAV...");
        // Vérifier tous les IDs nécessaires
        const requiredIds = ['login-area','search-view','inventory-view','log-view','admin-view','settings-view','seven-segment-display','inventory-table-body','response-output','component-input','show-search-view','show-inventory-view','show-log-view','show-admin-view','show-settings-view','login-button','logout-button','search-button','category-list','stock-form','component-category-select','save-component-button','export-inventory-csv-button','import-inventory-csv-button','log-table-body','log-feedback','import-csv-file','import-mode-upsert','import-mode-overwrite', 'modal-component-attributes', 'quantity-change-modal', 'loading-indicator']; // Ajout loading-indicator
        if (requiredIds.some(id => !document.getElementById(id))) { console.error("FATAL: Elément DOM essentiel manquant! Vérifiez index.html."); document.body.innerHTML = "<p style='color:red; padding:20px;'><b>Erreur init.</b> Vérifiez console (F12) & index.html.</p>"; return; }

        // --- Ajout des Écouteurs d'Événements ---
        // Navigation & Auth
        searchTabButton.addEventListener('click', () => setActiveView(searchView, searchTabButton));
        inventoryTabButton.addEventListener('click', () => setActiveView(inventoryView, inventoryTabButton));
        logTabButton.addEventListener('click', () => setActiveView(logView, logTabButton));
        adminTabButton.addEventListener('click', () => setActiveView(adminView, adminTabButton));
        settingsTabButton.addEventListener('click', () => setActiveView(settingsView, settingsTabButton));
        loginButton.addEventListener('click', handleLogin);
        loginPasswordInput?.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleLogin(); });
        loginCodeInput?.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleLogin(); });
        logoutButton.addEventListener('click', handleLogout);
        // Chat
        searchButtonChat.addEventListener('click', handleUserInput);
        componentInputChat.addEventListener('keypress', (event) => { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); handleUserInput(); } });
        responseOutputChat?.addEventListener('click', async (event) => { /* Gestion clic bouton 'Prendre' */ }); // Listener modifié en Étape 4
        // Inventaire
        applyInventoryFilterButton?.addEventListener('click', () => { currentInventoryFilters.category = inventoryCategoryFilter.value; currentInventoryFilters.search = inventorySearchFilter.value; displayInventory(1); });
        inventorySearchFilter?.addEventListener('keypress', (e) => { if (e.key === 'Enter') { applyInventoryFilterButton?.click(); } });
        inventoryPrevPageButton?.addEventListener('click', () => { if (currentInventoryPage > 1) { displayInventory(currentInventoryPage - 1); } });
        inventoryNextPageButton?.addEventListener('click', () => { if (!inventoryNextPageButton?.disabled) { displayInventory(currentInventoryPage + 1); } });
        inventoryTableBody.addEventListener('click', handleInventoryRowClick); // Gère modale
        // Log
        logPrevPageButton?.addEventListener('click', () => { if (currentLogPage > 1) { displayLog(currentLogPage - 1); } });
        logNextPageButton?.addEventListener('click', () => { if (!logNextPageButton?.disabled) { displayLog(currentLogPage + 1); } });
        logTableBody?.addEventListener('click', handleDeleteSingleLog); // Listener délégué pour Suppr.
        // (Listener pour Purger Tout est ajouté dynamiquement dans displayLog)
        // Admin & Settings
        addCategoryEventListeners();
        addComponentCategorySelectListener();
        addStockEventListeners();
        addSettingsEventListeners();
        // Modale
        modalDecreaseButton?.addEventListener('click', () => { /* ... */ });
        modalIncreaseButton?.addEventListener('click', () => { /* ... */ });
        modalCancelButton?.addEventListener('click', hideQuantityModal);
        modalOverlay?.addEventListener('click', (event) => { /* ... */ });
        modalConfirmButton?.addEventListener('click', async () => { /* ... */ });

        // --- Initialisation finale ---
        setupAuthListener();
        updateSevenSegmentDisplay(null);
        console.log("StockAV initialisé et prêt.");
    } // Fin initializeApp

    // --- Lancer l'application ---
    initializeApp();

}); // ----- FIN DU FICHIER script.js -----